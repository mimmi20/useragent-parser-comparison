# User Agent Parser Comparison

[![Build Status](https://travis-ci.com/diablomedia/useragent-parser-comparison.svg?branch=master)](https://travis-ci.com/diablomedia/useragent-parser-comparison) [![Type Coverage](https://shepherd.dev/github/diablomedia/useragent-parser-comparison/coverage.svg)](https://shepherd.dev/github/diablomedia/useragent-parser-comparison)

This application was put together to assist us in making a decision on which UserAgent parsing library to use, and then modified some to be a bit more user friendly to encourage use among the different parsing library maintainers.  It's still a bit work in progress, but in its current state it's very useful at benchmarking the different parsing libraries (across different languages) and comparing the results of the parsers against "known" useragents (right now these come from the parser libraries' unit tests, but a known list could be built and tested against).

This is loosely based on a benchmark utility that has been around for a while (but not currently maintained): https://github.com/kenjis/user-agent-parser-benchmarks

Right now this application is entirely a CLI application. Most of the data generated by the application is stored as JSON files, so it's certainly possible that a Web UI could be built around the data files which might make analysis easier.

The CLI is written in PHP (using the Symfony Console component), but the parsers (and tests) can be written in any language. Currently, most of the parsers are written in PHP, but the structure of the application (and how it calls the parsers) was intentionally built to support parsers from any language (PRs welcome!).

## Windows 10 system requirements

Enabling sqlite php extension.

Enabling wget command.

## How To Use

Clone this repo, then install composer dependencies (if composer isn't installed on your system, reference http://getcomposer.org):

`composer install`

Prepare the parsers and test suites:

`./bin/prepare`

This will initialize each of the parsers and test suites. This may require your system to have certain commands accessible on the path, like `composer` or `npm`.  This process will need to be improved to be more portable.

### Config

Copy the `config.php.dist` to `config.php`

### Run a comparison:

`./bin/console compare`

This will prompt you to select which Test Suite to use, as well as which parser you want to test against (multiples of both can be selected). After the tests are performed, a normalization step takes place where the values of the different properties will be normalized to make comparison more relevant (special characters and spaces replaced, lower-cased, various mappings performed). After that, the results can be analyzed.

### Perform a benchmark:

`./bin/console benchmark path/to/file --iterations=5`

This will prompt you to select which parsers to benchmark, then run the parsers against the specified file (needs to contain the useragents to parse, separated by new lines). After the benchmark is performed, a table like the one above will be output showing the time taken for each parser, as well as the memory consumed (reported by the parser script itself).

### Parse some useragents:

`./bin/console parse path/to/file`

Parses the user-agents in the specified file and outputs a table showing the agent and the parsed properties. Can dump this output to CSV format.

## How Parsers are Compared

### Accuracy

Every parser extracts different pieces of data and formats/names the data differently, so comparing the output of one parser to another isn't an easy thing to do. Obviously you should pick a parser that extracts the data that **you** need, not the one that scores the best here.  That said, we did want a way to compare the relative accuracy of a parser when it's run against useragents for which the properties are known.  In order to do this across different parsers of varying "complete-ness" we selected just a handful of properties that are shared across most parsers we've looked at so far (Browser Name, Browser Version, Platform/OS Name, Platform/OS Version, Device Name, Device Brand, Device Type, Device "Is Mobile?" Flag).  This list is subject to change, and perhaps even something that we could make configurable for any given comparison.

Each of the property values are then normalized, mainly by lowercasing the value and stripping out special characters and spaces ("google-bot" and "Google Bot" would become just "googlebot"). Unfortunately that's not enough, as parsers will name some of the common values differently, so there's a mapping stage of normalization. This handles cases like "IE" and "Internet Explorer" referencing the same value.  This is done at the "data source" level, meaning, where the parser gets its useragent data from (some parsers use a general data source, like the data from the Browscap project, others use their own).  While this handles a lot of data mismatches, it doesn't deal with all of it, especially when we look at Device Name parsing.

For this reason, the report you see above was broken into different sections, showing how well a parser interpreted the Browser, Platform/OS and Device values.  Typically the Device section is the lowest accuracy for a parser (except against its own test suite) due to the inconsistencies in naming devices and because it contains four properties (that must match) instead of just two.

#### The "Accuracy Score"

To account for parsers (and test suites) that don't contain certain pieces of data, we award a "point" to a parser when it correctly identifies a property, but don't penalize the parser if it (as a whole) doesn't provide a property that the test suite it is run against does.  For example, the Woothee parser doesn't contain any device data except for the "type", so for the Device section it's only scored on whether or not it parsed the "type" property correctly. On the flip side of that, parsers aren't penalized for providing data that a test suite doesn't test for.

### Benchmarking

The benchmark command doesn't do anything special other than run a parser against a list of useragents a specified number of times. The timing information is collected by the script that runs the parser and the benchmark script, just in case there is a lot of time spent in application startup that can't be measured by the parser script itself (an example of this is PHP's native `get_browser` function. When PHP is configured to load a browscap.ini file, it reads the entire file at PHP startup, which can't be measured from within a PHP script). We've broken out the times so it's easy to tell where time is spent for any given parser. This includes an "initialization time" cost and the actual "parse time" for each useragent parsed. Any other costs that the runner script imposes that aren't measured as part of the other two times are measured in the "extra time" column.

## The Parsers

The parsers can be any useragent parser from any language (web API based parsers are possible, though rate limits and network traffic should be considered for some of the larger test suites). All this application needs from a parser is an executable script named "parse" that accepts a filename as the first parameter (which contains the useragents to parse, one on each line of the file) and returns the parsed data in the following JSON format:

```json
{
    "results": [
        {
            "useragent": "Mozilla/5.0 (iPad; U; CPU OS 3_2_1 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) Mobile/7B405",
            "parsed": {
                "browser": {
                    "name": "Mobile Safari UIWebView",
                    "version": "0.0"
                },
                "platform": {
                    "name": "iOS",
                    "version": "unknown"
                },
                "device": {
                    "name": "iPad",
                    "brand": "Apple Inc",
                    "type": "Tablet",
                    "ismobile": "true"
                }
            },
            "time": 0.003
        }
    ],
    "parse_time": 0.105,
    "init_time": 0.003,
    "memory_used": 3456745
}
```

Currently this is the list of parsers included:

#### Javascript
* 3rd-Eden Useragent 2.x (https://github.com/3rd-Eden/useragent)
* Browscap JS 1.x (https://github.com/mimmi20/browscap-js/tree/v1)
* Browscap JS 2.x (https://github.com/mimmi20/browscap-js)
* Device Detector for Nodejs 0.x (https://github.com/MiGatoSeneca/device-detector-node)
* UAParser.js (https://github.com/faisalman/ua-parser-js)
* WhichBrowser JS 0.x (https://github.com/WhichBrowser/Parser-JavaScript)
* Woothee JS 1.x (https://github.com/woothee/woothee-js)

#### PHP
 * Browscap PHP 2.x (https://github.com/browscap/browscap-php/tree/2.x)
 * Browscap PHP 3.x (Full, Standard and Lite) (https://github.com/browscap/browscap-php/tree/3.1.0)
 * Browscap PHP 4.x (Full) (https://github.com/browscap/browscap-php)
 * Crossjoin Browscap 1.x (https://github.com/crossjoin/Browscap/tree/1.x)
 * Crossjoin Browscap 2.x (https://github.com/crossjoin/Browscap/tree/2.x)
 * Crossjoin Browscap 3.x (PHP7 only) (https://github.com/crossjoin/Browscap/tree/3.x)
 * BrowserDetector 5.x (https://github.com/mimmi20/BrowserDetector)
 * Donatj UserAgent Parser 0.x (https://github.com/donatj/PhpUserAgent)
 * Endorphin Browser Detector 3.x (https://github.com/endorphin-studio/browser-detector)
 * Jenssegers Agent 2.x (https://github.com/jenssegers/agent)
 * PHP's Native `get_browser` (https://secure.php.net/get_browser) - It is **strongly** recommended that this parser isn't used for large useragent lists unless you're on PHP **7.0.15/7.1.1 or later**. It is **much** too slow otherwise.
 * Piwik Device Detector 3.x (https://github.com/piwik/device-detector)
 * Sinergi Browser Detector 6.x (https://github.com/sinergi/php-browser-detector)
 * UA Parser PHP 3.x (https://github.com/ua-parser/uap-php)
 * WhichBrowser 2.x (https://github.com/WhichBrowser/Parser)
 * Wolfcast BrowserDetection 2.x (https://github.com/Wolfcast/BrowserDetection)
 * Woothee PHP 1.x (https://github.com/woothee/woothee-php)
 * Yzalis UA-Parser 0.x (https://github.com/yzalis/UAParser)
 * ZSXSoft PHP-UserAgent 1.x (https://github.com/zsxsoft/php-useragent)

## The Test Suites

Like the parsers, there is no language requirement for a test suite to be included here.  The only requirement is that an executable script named `build` can be called and returns JSON in the following format:

```json
{
    "Mozilla/5.0 (iPad; U; CPU OS 3_2_1 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) Mobile/7B405": {
        "browser": {
            "name": "Mobile Safari UIWebView",
            "version": "0.0"
        },
        "platform": {
            "name": "iOS",
            "version": "unknown"
        },
        "device": {
            "name": "iPad",
            "brand": "Apple Inc",
            "type": "Tablet",
            "ismobile": "true"
        }
    }
}
```

Due to the nature of this format, it is a requirement that any given unique useragent has only one set of parsed fields. If a test suite contains different sets of values for a single useragent (across different files, or because other headers are expected to be present), then these either need to be excluded or merged together.

These are the test suites that are currently included:

 * Browscap (https://github.com/browscap/browscap)
 * Donatj (https://github.com/donatj/PhpUserAgent)
 * Endorphin (https://github.com/endorphin-studio/browser-detector)
 * Piwik Device Detector (https://github.com/piwik/device-detector)
 * Sinergi (https://github.com/sinergi/php-browser-detector)
 * UA Parser (https://github.com/ua-parser/uap-core)
 * UAParser.js (https://github.com/faisalman/ua-parser-js)
 * WhichBrowser (https://github.com/WhichBrowser/Parser)
 * Woothee (https://github.com/woothee/woothee)
 * ZSXSoft (https://github.com/zsxsoft/php-useragent)
